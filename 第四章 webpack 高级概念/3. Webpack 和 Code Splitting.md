# Webpack 和 Code Splitting

这节给大家讲 webpack  和 code splitting 之间的关系。webpack 大家都已经接触过了，那 code splitting 指的是代码分割。什么是代码分割？webpack 和 代码分割之间有什么联系？

关于 code splitting 这个知识点，涉及到的 webpack 的配置项非常多。所以分两节讲，本节讲 **webpack 与 code splitting 之间的关系**到底是什么？下节讲在 webpack 中做 code splitting 涉及到的大量**配置**内容？



## 遗留问题

由于，使用webpack-dev-server打包出来的内容在内存中，无法看到。

- 所以我们首先来创建 npm scripts 命令，来使用开发环境的webpack配置帮助我们打包。

```json
"dev-build": "webpack --config ./build/webpack.dev.js"
```

- 运行 npm run dev-build，发现打包dist目录被放置在了 build目录中。

- 修改 webpack.common.js 的 output 路径

  ```js
  output: {
          filename: '[name].js',
          path: path.resolve(__dirname, '../dist') // 在 dist 前面加 ../
   },
  ```

  使得打包生成的dist 目录放置到 lesson 根目录下的 dist 目录，而不是当前 build 目录下的 dist 目录。

- 重新打包则 dist 目录就到根目录下了。

  

## webpack 与 code splitting 关系

code splitting 到底是什么，我给大家举一个非常简单的例子来引出这个话题。

我们使用第三方模块  lodash 来讲解。

- 安装 lodash

  ```js
   npm i lodash --save
  ```

- 在 src/index.js 中

  ```js
  import _ from 'lodash';
  console.log(_.join(['a', 'b', 'c'], '***')); // 用*** 连接 a,b,c
  ```

  其实上面的代码引入了一个库，并使用这个库做字符串连接操作。

- 运行打包

  ```js
  npm run dev-build
  ```

- 打开 dist 目录，运行 index.html 打开控制台发现：

  ```js
  a***b***c
  ```

  

我们来看，现在打包生成的 dist 目录中有一个 main.js。也就是说 lodash 这个工具库以及下面写的业务代码都被**打包到了一个文件**中。

假设业务逻辑非常多，比如我们引入10万行业务逻辑，如果现在这种方式打包，它会把工具库和业务逻辑都打包到 main.js 中。

```js
import _ from 'lodash'; // 工具库

console.log(_.join(['a', 'b', 'c'], '***')); 
// 此处省略10万行业务逻辑...
```

这种方式做打包有没有问题？没有任何问题。能够正确执行且不会出错任何代码报错。但大家想，这么做实际上会带来一个**潜在的问题**。潜在的问题是什么呢？

假设 lodash 有 1MB，业务代码也有 1MB，假设打包时不做压缩，则打包生成的 main.js 应该有 2MB。如果通过这种方式生成了一个 2MB的文件，那就意味着如果用户访问我们的 index.html 文件，它想输出我们的业务逻辑的话，就要先去加载一个 2MB 的 js 文件，它要等这个 js 文件加载完成之后才会去执行文件里面的逻辑，才会把页面展示出来。所以这样打包带来的第一个问题就是：**打包文件会很大，加载时间会长**。

其实它还会带来另外一个问题，我们说 lodash 是一个第三方的库，我们一般是不会去改它的。但是我们的业务逻辑是经常会被改变的。假设我们修改了业务逻辑，然后重新做一次打包，就会打包出一个新的 main.js 文件，它是 2MB。那用户如果**重新访问** index.html 页面的话，又要加载 2MB 的内容。

第一个问题是，用户先访问 index.html 时会加载 2MB的 main.js，加载时间会很长。

第二个问题是，假设修改了业务代码，则用户需要重新加载 main.js 才能获取到最新代码，执行显示最新内容，也就意味着代码只要一变更，用户就需要重新加载 2MB的内容。

想一想，有没有办法解决这个问题呢？其实是有的。



## 手动代码分割

- 在 src 目录下，再创建一个 lodash.js:

```js
import _ from 'lodash';
window._ = _;
```

把 index.js 中关于 lodash 的引入放到 lodash.js 里面，然后把lodash 挂载到全局 window 对象上。这样我们就可以在控制台或者其他地方就可以直接去使用 _ 这个变量了。这就是 lodash.js 这个文件的作用。

- 接着再来改 index.js ，直接写业务逻辑即可，无需引入 lodash:

```js
console.log(_.join(['a', 'b', 'c'], '***'));
// 此处省略10万行业务逻辑
console.log(_.join(['a', 'b', 'c'], '***'));
```

- 在 webpack.common.js 中配置入口：

```js
entry: {
        lodash: './src/lodash.js',
        main: './src/index.js'
 },
```

- 重新打包

```js
npm run dev-build
```

可以看到 dist 目录中打包出了 index.html 、main.js 和 lodash.js。且 index.html 会同时引入 lodash.js 和 main.js 。

现在我们就把之前的一个 main.js 抽成了两个代码，一个是 main.js 一个是lodash.js。

我们打开 index.html 也可以正确输出业务代码。没有任何问题。

```js
a***b***c
a***b***c
```

这样我们就换了一种打包方式。



## 对比两种方式

第一种打包方式：

main.js 一共有 2MB，意味着用户需要加载完 2MB的 js 才能展示页面。

第二种打包方式：

但是现在我们把 main.js 拆成了两个 js 文件，分别是 dist/lodash.js 和 dist/main.js 。它俩各 1MB。因为在 src/lodash.js 中，我们只引入了 lodash，而在 src/index.js 中，我们只放了业务代码，所以它们各有 1MB。

此时，假设用户访问 dist/index.html，则不需要去加载 2MB的内容，则需要加载 2 个 1MB 的内容，大家知道浏览器可以并行加载文件，在大量的实践中发现，并行加载两个 1MB 的代码可能比加载一个 2MB 的代码要稍微快一点，当然这不是绝对的。再来想一下，假设我们之前修改了业务代码，用户需要把一个 2MB 的代码重新加载一次才能拿到新的业务代码产生的内容。但是现在这种打包方式，如果我们的业务逻辑产生了变更，用户需要不需要重新加载 dist/lodash.js 文件呀？实际上不需要。因为 lodash 没有做任何变更，它在用户的浏览器里是有缓存的。所以当页面**业务**逻辑发生**变化**时，**只**要加载 **dist/main.js** 即可。也就是当你修改了页面代码并重新打包发布上线的时候，dist/lodash.js不需要加载，它在缓存里就有。它只要重新加载 dist/main.js就可以了。所以这样的话，重新访问页面的时候第二种方式就会有效的**提升**页面展示的**速度**。

通过对代码**公用部分进行拆分**来提升项目运行的速度，这种代码的拆分就是要给大家讲的核心概念---**code splitting**。

所以讲到这里大家应该已经清楚 code splitting 的概念了。没有 code splitting 我们写代码完全没有任何问题，但是有了 code splitting，我们通过对代码拆分，就可以让我们的代码执行的**性能**更高一些，或者让**用户体验**更好一些。

那 code splitting 是不是和 webpack 有关系呢？其实在没有 webpack 之前，我们通过自己对代码进行拆分，也可能有效提升项目的性能，所以 **code splitting 本质上和 webpack 没有任何关系**。那为什么只要一提到 webpack，很多时候我们在各个地方都能听说到 webpack 里面有 code splitting 这样一个东西。现在我们说 webpack 已经和 code splitting 有所绑定了呢？这是因为  webpack 有一些插件可以非常容易帮我实现 code splitting，也就是代码分割这样的功能。在 webpack 4 里面有一个插件叫 splitChunksPlugin。这个插件直接就和 webpack 做了捆绑且不用安装直接就可以用。那么如果你使用这种插件再做代码分割的时候你会发现它非常简单。

我们来对比下，现在我们做的代码分割实际上自己手动把 main.js 拆成了两个文件，一个是 lodash.js ，一个是 main.js，它不够智能。在 webpack 中通过它自带的插件，可以智能的帮我们做 code splitting :

```js
// webpack.common.js
optimization: {
        // Code Splitting
      splitChunks: {
          chunks: 'all'
      }
}
```









